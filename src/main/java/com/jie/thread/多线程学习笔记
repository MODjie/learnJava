一、线程的生命周期：（2019-7-18）
    1、新生（NEW）:实例化了Thread对象后
    2、就绪、运行（RUNNABLE）;
        就绪：
           （1）调用了Thread.start()方法，
           （2）调用了yield方法，
           （3）阻塞消除，
           （4）jvm将本地线程切换到其他线程
        运行：
            线程正常运行时
    3、阻塞（WAITING、BLOCKED、TIME_WAITING）;
        （1）WAITING: 一个线程在等待另一个线程执行一个动作时在这个状态，例如执行join方法之后
        （2）BLOCKED：这种状态是指一个阻塞线程在等待monitor锁
        （3）TIME_WAITING：一个线程在一个特定的等待时间内等待另一个线程完成一个动作会在这个状态，例如调用了sleep方法之后
        阻塞的解释：https://segmentfault.com/a/1190000010973341
    4、结束（TERMINATE）：线程执行完毕
二、Thread类常用的方法
    1、静态方法
        （1）sleep()：使线程进入阻塞（TIME_WAITING）状态，对应时间过后线程进入就绪状态。
        （2）yield(): 暂停线程，礼让出CPU，使线程进入就绪状态。
        （3）currentThread(): 获取当前正在运行的线程的实例。
        （4）activeCount(): 获取当前存活的线程数。
    2、普通方法
        （1）join(): 插队方法，在thread1中调用thread2的join方法，thread1暂停，进入阻塞(WAITING)状态，等thread2执行完毕后继续执行thread1。
        （2）start(): 使线程进入就绪状态。
        （3）isAlive(): 判断被调用线程是否存活。
三、线程的优先级：（2019-7-19）
    1、线程的优先级分为三个等级：MIN_PRIORITY:1,NORMAL_PRIORITY:5,MAX_PRIORITY:10,数字越大优先级越高。
    2、优先级高只代表CPU调度的概率变大，而不是绝对的CPU一定会先调。
    3、一定要在调用start方法之前设置优先级，通过thread.setPriority()方法设置。

四、守护线程：
    1、使用thread.setDaemon(true)方法将用户线程设置为守护线程。
    2、守护线程是在后台默默运行的线程，CPU以用户线程为准，当用户线程运行结束之后，守护线程就算没执行完毕也会停止。
五、线程同步：（2019-7-27）
    1、一个对象被多个线程同时使用，就会出现线程不安全的状态。
    2、使用synchronized关键字实现线程同步：
        （1）synchronized方法：在需要实现线程同步的方法加入synchronized关键字，就可以实现线程同步，不过会影响性能，假设整个方法体内有多个对象，
             但是只有一个对象存在线程不安全的问题，那么其他的对象也被锁住了，从而影响性能。
        （2）synchronized块：在方法内部的某一段代码块加此关键字，并使用"{}"进行包裹，不过这样可能出现锁错对象，或者锁的范围太小，如果这样则还是
             线程不安全，如果锁的范围太大，同样会造成资源浪费，影响性能。
    3、synchronized是锁住资源，而不是锁方法：在方法前面加关键字表示锁住当前这个对象，如果方法体内访问的对象也是当前对象的则可以实现同步，如果非
       本对象，则仍然是无效的，应该使用synchronized块，锁住存在线程不安全的对象。
    4、尽量使用同步块，可以更细粒度的锁住线程不安全的代码
    5、同步并发容器：CopyOnWriteArrayList内部加了同步锁，在并发操作的时候可以保证线程安全
六、死锁：
    1、多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源，导致两个或多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时
       拥有“两个以上对象的锁时”，就可能发生死锁问题。
       例如：两个女生都想化妆，但是女生1拥有化妆品，女生2拥有镜子，但是都在等待对方把资源给自己，然后就僵持住了，谁也化不了妆。就产生死锁了。
七、生产者消费者模式：
    1、不是23种设计模式种的一种，是为了解决线程通信的模式，并发协作模式
    2、实现生产者的方式有两种：
        （1）管程法：使用并发容器作为缓冲区，将生产者与消费者解耦，生产者只负责生产数据，不用在意谁去调用，只要缓冲区能放得下就继续生产。消费者
             只负责消费数据，只要缓冲区还有数据，就继续消费。
        （2）信号灯法: 使用标志变量作为信号灯，灯亮（true）生产，灯灭（false）消费（顺序可换）。
八、定时调度
    1、java.util.Timer类的多个shecdule重写方法，用来实现定时调度，其中要给参数为java.util.TimerTask类，需要实现定时调度任务的类需要继承这个抽象类。
