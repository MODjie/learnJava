一、线程的生命周期：（2019-7-18）
    1、新生（NEW）:实例化了Thread对象后
    2、就绪、运行（RUNNABLE）;
        就绪：
           （1）调用了Thread.start()方法，
           （2）调用了yield方法，
           （3）阻塞消除，
           （4）jvm将本地线程切换到其他线程
        运行：
            线程正常运行时
    3、阻塞（WAITING、BLOCKED、TIME_WAITING）;
        （1）WAITING: 一个线程在等待另一个线程执行一个动作时在这个状态，例如执行join方法之后
        （2）BLOCKED：这种状态是指一个阻塞线程在等待monitor锁
        （3）TIME_WAITING：一个线程在一个特定的等待时间内等待另一个线程完成一个动作会在这个状态，例如调用了sleep方法之后
        阻塞的解释：https://segmentfault.com/a/1190000010973341
    4、结束（TERMINATE）：线程执行完毕
二、Thread类常用的方法
    1、静态方法
        （1）sleep()：使线程进入阻塞（TIME_WAITING）状态，对应时间过后线程进入就绪状态。
        （2）yield(): 暂停线程，礼让出CPU，使线程进入就绪状态。
        （3）currentThread(): 获取当前正在运行的线程的实例。
        （4）activeCount(): 获取当前存活的线程数。
    2、普通方法
        （1）join(): 插队方法，在thread1中调用thread2的join方法，thread1暂停，进入阻塞(WAITING)状态，等thread2执行完毕后继续执行thread1。
        （2）start(): 使线程进入就绪状态。
        （3）isAlive(): 判断被调用线程是否存活。
三、线程的优先级：（2019-7-19）
    1、线程的优先级分为三个等级：MIN_PRIORITY:1,NORMAL_PRIORITY:5,MAX_PRIORITY:10,数字越大优先级越高。
    2、优先级高只代表CPU调度的概率变大，而不是绝对的CPU一定会先调。
    3、一定要在调用start方法之前设置优先级，通过thread.setPriority()方法设置。

四、守护线程：
    1、使用thread.setDaemon(true)方法将用户线程设置为守护线程。
    2、守护线程是在后台默默运行的线程，CPU以用户线程为准，当用户线程运行结束之后，守护线程就算没执行完毕也会停止。
五、线程同步：（2019-7-27）
    1、一个对象被多个线程同时使用，就会出现线程不安全的状态。
    2、使用synchronized关键字实现线程同步：
        （1）synchronized方法：在需要实现线程同步的方法加入synchronized关键字，就可以实现线程同步，不过会影响性能，假设整个方法体内有多个对象，
             但是只有一个对象存在线程不安全的问题，那么其他的对象也被锁住了，从而影响性能。
        （2）synchronized块：在方法内部的某一段代码块加此关键字，并使用"{}"进行包裹，不过这样可能出现锁错对象，或者锁的范围太小，如果这样则还是
             线程不安全，如果锁的范围太大，同样会造成资源浪费，影响性能。
    3、synchronized是锁住资源，而不是锁方法：在方法前面加关键字表示锁住当前这个对象，如果方法体内访问的对象也是当前对象的则可以实现同步，如果非
       本对象，则仍然是无效的，应该使用synchronized块，锁住存在线程不安全的对象。
    4、尽量使用同步块，可以更细粒度的锁住线程不安全的代码
    5、同步并发容器：CopyOnWriteArrayList内部加了同步锁，在并发操作的时候可以保证线程安全